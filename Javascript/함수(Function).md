# 함수(Function)

- 자바스크립트는 함수 지향형 프로그래밍 , 최근 들어서는 객체 지향의 장점들이 녹아드는 중

- 함수 지향이란 무엇일까? 프로그래밍 패러다임의 한 종류, 순수 함수를 조합하고 함수를 일급 객체로서 사용하여 프로그래밍 하는 방식

- 프로그래밍 패러다임이란?
  개발자에게 프로그래머로서의 관점을 갖게하고 결정하는 역할 => 개발 방법

- 명령형 / 절차 지향 : 순서를 중요 -> 컴퓨터의 처리구조와 유사, 속도가 빠름(C언어) - 치명적인 단점 : 무조건 순서대로 진행,수정해야 된다. 앞에 작업 수정시 뒤에 작업도 수정해야 된다. 유지보수가 빡셈

- c언어 - 저급언어 - 수준이 낮다는게 아닌 레벨이 낮은 것

- 객체 지향 : 각 프로그램 구조에서 오류가 있을 시 그 오류가 있는 곳만 수정해서 사용하는 것. 객체(집단)의 상호 작용을 중시, 유지 보수 용이 - Java, C++, C# /
  a,b,c가 있는 와중에 a가 고장나면 a만 수정하면 되는 것 그래도 a,b,c가 서로 소통하기 때문에 순서는 중요하다.

- 선언형 (어떻게 할 것인가보다는 무엇을 할 것인가가 중요)
  함수 지향 : 순수 함수를 조합하고 프로그래밍 하는 방식 (Javscript)

- 이 구분도 옛날 이야기 요즘엔 객체지향과 함수지향의 경계선이 모호하다.
  현재는 각 패러다임의 장점을 살려서 개발한다. 그러므로 크게 구분짓는 것은 의미가 없다.
  자바스크립트를 좀더 객체 지향화 시킨것이 타입스크립트다.

- 불변성 = 함수 밖에서 데이터의 변형을 일으켜서는 안된다
- 클로저 = 부모 함수가 실행 종료되어도 참조할 수 있는 내부 함수 및 값은 기억된다
- 순수함수 = 입력 값에만 의존하고 부수 과는 연산에 영향을 미치지 않는다
- 일급 객체 함수 = 함수를 입력값으로 사용할 수 있도록 반환 값으로도 사용할 수 있다
- 유지관리가능성 = 외부 효과에 의존되지 않으며 해당 부분만 수정하면 되기에 유지보수가 용이하다
- 모듈화 = 함수를 분리하여 재사용 및 관리가 용이하도록 구성해야한다
- 부수효과 = 함수 밖에서 함수의 연산에 영향을 끼치면 안된다(외부효과, 사이드 이펙트)
- 참조 투명성 = 동일한 값에는 항상 동일한 반환 값

---

## 자바스크립트 규칙

> - 특징
>   - 캡슐화
>   - 상속
>   - 추상화

> - 원칙
>   - solid
>   - 단일 책임 원칙
>   - 개방 폐쇄 원칙
>   - 리스코프 치환 원칙
>   - 인터페이스 분리 원칙
>   - 의존성 역천 원칙

## 함수

어떠한 기능을 만든다. a,b(input) => +(opertage) => a+b(output)

2가지 수 => 합치기 => 합친 결과값

ex)
나는 두개의 숫자를 전달받고 두 수를 합치는 함수(기능)을 작성하고 싶다.

```jsx
function addNumber(a, b) {
  return a + b;
}
```

자바에서는 메서드라고 부른다.

### 선언부

- 선언부는 함수를 실행하는 것이 아니라 기능만 구성하여 컴퓨터에게 기억시키는 것 -> 재사용시키기 위해서
- 나는 언젠가 이 기능을 사용할 수 있어!!
- function 함수명(파라미터1,2,3,...) - 변수와 이름이 같아야된다. 다르면 알아보기 힘들거나 작동을 안할 수 있음. 항상 유추 가능할 수 있게 작성
- 파라미터 : 실행부에서 전달된 값, 매개변수, 파람, 인자 - 모두 같은 말이다.

```
{
하나의 구역을 만들어주고
.... 연산
반환 값(생략 가능)
}
```

## 실행부

함수명(5, 3)
함수명(전달값1, 전달값2)

반환값

```
function sum(a,b) {  <-------------선언
console.log(a+b)
}

const result = sum(3, 5) <-------실행 //8
console.log(result)  //undefined ------------> 8
```

> - 반환 값은 해당 함수에 실행부에 값을 부여한다는 의미 sum(3, 5) = 8
> - 반환을 생략하면 sum(3, 5)는 기능은 실행하지만 자체가 갖는 값은 없습니다. 따라서 함수의 기능을 통해 나온 결과값을 함수 외부에서 사용하고 싶을 때 함수에 값을 반환해서 외부에서 사용할 수 있도록 return
>   외부에서 사용하고 싶으면 function으로 호출 내부에서 사용만 할려면 return으로 반환

## 기명함수, 익명함수

```jsx
function hello() {
  console.log("hello");
}
```

- 기명함수 - hello라는 이름만 가지고 어디서든 재사용할 수 있고 파악할 수 있게 하는 것function (){

```jsx
console.log("world")
}
```

- 익명함수 - 재사용 가능성이 없을 때 굳이 이름을 주지 않고 사용 - 일회성으로 사용할 때 사용
- 하지만 이름이 없으면 실행부 호출X, 콜백 함수나 클로저, 즉시실행함수로 호출

## 재귀함수

함수 안에서 동일한 함수를 실행(반복)

[코딩테스트, 최단 경로, 깊이 탐색 관련 알고리즘의 단골]

실무에서는 사용하는 경우는 그렇게 많지는 않다.

```jsx
function f(n){
if(n <= 1){
return 1
}
return n + f(n-1)
}
f(10) - 10부터 1까지 더하는 함수
```

## 즉시실행함수

실행부 없이 선어부만으로 바로 실행되는 함수

바로 실행되기 때문에 익명 함수로 실행하는 것이 보통 괄호 두개 열어준다.

첫번째 괄호에 함수 정의
()() => (func)()
(function(){
... 실행문
})()

## 화살표 함수

- ES6,7 function 키워드 대신 화살표(=>)를 사용하여 보다 간략한 방법으로 함수 선언
- this 바인딩의 차이가 존재하므로 메서드 용도로는 사용하지 않는다.

```jsx
ex)
기명함수 표기
function a (param1, param2){
...
}

const a = (param1, param2) => {
...
}

익명함수 표기
function(){
}
() => {
}

(()=>{
console.log("안녕하세요")
})()
// 익명함수, 화살표함수, 즉시실행함수

function printName(name){
console.log(name)
}

printName("장상준") //장상준

function addNumber(num1, num2){
console.log(num1 + num2)
return num1 + num2
}

addNumber(1,2) //3
console.log(addNumber(1,2) + 1) //3,4 리턴은 반환값이예요 라고 말하기

function f(n){
if(n <= 1){
return 1
}
return n + f(n-1)
}
console.log(f(10)) //55

(()=>{
    console.log("안녕하세요")
})()
// 익명함수, 화살표함수, 즉시실행함수

function printName(name){
    console.log(name)
}

printName("장상준") //장상준

function addNumber(num1, num2){
    console.log(num1 + num2)
    return num1 + num2
}

addNumber(1,2) //3
console.log(addNumber(1,2) + 1) //3,4 리턴은 반환값이예요 라고 말하기

function f(n){
    if(n <= 1){
        return 1
    }
    return n + f(n-1)
}
console.log(f(10)) //55

/*
함수를 작성하는 이유는 여러분들이 작성한 비즈니스 로직(기능)을 컴퓨터에게 기억시키고 재사용하기 위함

return 값이 없다면 해당 실행부는 함수의 기능을 실행은 하지만
값 자체는 undefined고 return이 있다면 해당 return 값을 실행부에 할당

따라서 return 값의 유무는 여러분들이 설계한 로직 하에 해당 함수의 값이 있어야하는가 없는가
ex). 해당 로직 이후에 비즈니스 로직의 결과값을 사용해야하는가
*/

for(let i=0; i<10; i++){
    console.log('현재 숫자는, ${i+1}입니다.')
}

// 결과는 어떻게 나올까요?
// 현재 숫자는 1입니다. ~ 현재 숫자는 10입니다.

// 중첩 for문

for(let i=0; i<6; i++){
    for(let j=1; j<=9; j++){
        console.log('${i}학년 ${j}반')
        // 1학년 1반 ~ 1학년 9반 -> i++;
        // 2학년 1반 ~ 2학년 9반 -> i++;
    }
}


for(let i=0; i<10; i++){
    console.log('현재 숫자는, ${i+1}입니다.')
}

// 결과는 어떻게 나올까요?
// 현재 숫자는 1입니다. ~ 현재 숫자는 10입니다.

// 중첩 for문

for(let i=0; i<6; i++){
    for(let j=1; j<=9; j++){
        console.log('${i}학년 ${j}반')
        // 1학년 1반 ~ 1학년 9반 -> i++;
        // 2학년 1반 ~ 2학년 9반 -> i++;
    }
}


// 구구단
// 1~9단

// ex)
// "1*1 = 1"
// ...
// "9*9 = 81"

for(let i=1; i<=9; i++){
    console.log('==========${i}단=============')//1~9
    for(let j=1; j<=9; j++){
        console.log('${i}*${j}=${i*j}')
    }
}

// for문을 언제 사용하느냐
// 배열에 담겨있는 요소의 길이만큼 반복

const arr = [1,2,3,4,5,6,7,8,9]
for(let i=0; i<arr.length; i++){
    console.log(arr[i]) //1~9
}
// i = index의 줄임말이다.


--------------------------------------------

for + array
const arr = [0,1,2,3]
for(let i = 0; i<arr.length; i++){
  console.log(arr[i])
}
// 0,1,2,3
/*
for문은 여러분들이 원하는 만큼 조건식을 설정해서 순회
index의 값을 마음대로 수정할 수 있다.
*/

arr.forEach((value,index,array)=>{
  console.log(value,index,array)
})
// 0,0,[0,1,2,3] -> 1,1,[0,1,2,3]
// 현재요소, 인텍스, 원본배열
/*
모든 요소를 순회 + 순서 보장 및 인덱스를 활용
*/

for(let el of arr){
  console.log(el)
}
/*
모든 요소를 순회, 단지 순서를 보장되지 않는다. 먼저 온 순서대로 나열
*/

const user = {
  name : "장상준",
  height : 190,
  age : 20
}

for(let key in user){
  console.log(key) // name, height, age
  console.log(user[key]) // "장상준", 190, 20
}
// 왜 이렇게 생겼나?
// 원래 작성법 -> 밑에 오브젝트.키
// [name, height, age]
Object.keys(user).forEach((key)=>{
  console.log(user[key])
})

// ["장상준", 190, 20]
Object.values(user)

// [[name,"장상준"],[height, 190],[age,20]] 키와 벨류가 동시에 필요할 때 사용한다.
Object.entries(user)
for(let[key, value] of user){
  console.log(key, value)
}

// 배열에서 순서 상관없이 순회만 하는거면 for of, 순서까지 중요하다 index필요하다 forEach, 인덱스를 조종해야한다 for
// 객체는 반복할 수 있는기? -> 반복할 수 없다!!
```
