# JavaScript 총정리

## JS (Java Script)

    1996년 3월 10일
    "html, css"은 정적이다. ==> 페이지가 동적으로 움직이지 않았음 => 페이지를 움직이게 만들고 싶다. -> JavaScript (가벼운 언어)
    10일만에 만들어진 동작만을 위한 가벼운 언어였다.
    성능이 되게 저하되어있었음 <---- google이 진화시켰다
    2009년 v8 엔진(브라우저 엔진) 출시

    JavasScript 인터프리터 언어
        => 변환 과정 없이 소스 코드를 바로 실행할 수 있도록 프로그래밍 언어 ex) js. python

    v8엔진
    java script를 필요에 따라 컴파일 할 수 있도록 성능을 높이는 엔진
    - Java Script의 기능과 확장성이 넓어짐

    컴파일 언어
    A라는 언어 -> B라는 언어 변환하는 과정
    ex) java ,C#, swift ...
    안녕하세요 -> 기계어로 컴파일 -> 000100101011001010001

---

    JavaScript !== Java
    Mocha -- > Live Script ---> Java의 이름을 빌려서 JavaScript가 된 것 뿐

---

## Java Script 적용법

    -내부-
    html 태그 안에
    <script>
    ... Java script
    </script>
    단, 위치와 순서는 중요
    자바스크립트는 위에서 아래로 읽음, 따라서 선언 되어있지 않은 값이나 DOM(요소)를 가지고 오면 찾을 수 없다

    -외부-
    \*.js (확장자명은 js)
    <script src="경로" />

---

## 자바스크립트 입출력

    * 입력 -> 연산 -> 출력
    언제나 코드를 설계해야한다!! 그 후에 구현을 해야한다.
    복습한 것을 가지고 나만의 설계를 만들어야한다.

    출력 값은 이미 알고 있는 값
    출력을 토대로 입력 값을 일부 에상
    연산을 하기 전 먼저 설계를 완료하라 ----> 구현 가능한지 검증
    설계가 완료되면 코드를 작성한다
    예외 상황을 예상한다. (오류 예측)


    1. 입력
        prompt()

    2. * 출력 -- 디버깅 !!!!
        console.log()
        console.error()

        -알림창 (사용자에게 보여주기 위한 용도)-
        -반드시 broweser 환경에서만 작동해야한다-

        중간중간에 console을 찍어봐서 원하는대로 작동하는지 확인해봐야 한다.
        에러를 줄이는 연습을 해야한다!!

        alert()
        confirm()

---

    자바스크립트가 브라우저 내에서 작동해야한다는 건 alert ,confirm과 같이 브라우저 내부 기능을 사용할 때 DOM API (요소나 태그)에 접근해야할 때
    .js 확장자를 터미널로 직접 실행 (브라우저x)

    NodeJS 설치
    크롬의 V8엔진을 브라우저 바깥으로 꺼내어 JS를 브라우저가 아닌 환경에서도 실행시킬 수 있도록 하는 런타임(환경)
    이로 인해 개발자들은 JS로 웹서버를 구성하여 백엔드를 만들 수 있고 프론트엔드 프레임워크 개발도 가능

    reactJS와 같은 js 라이브러리들이 이 nodeJS 환경에서 실행
    https://nodejs.org/ko/
    설치 -> 확인 (node -v)

---

## 자바스크립트의 자료형

    컴퓨터에서 어떠한 값을 사용하려고 하면 컴퓨터에게 값을 기억 시킬 필요가 있다.

    예를 들면 나는 a라는 바구니에 숫자 5를 담아놓을거야 (선언 및 할당) 그리고 어디서든 a라는 이름을 사용하면 숫자5가 나오도록 할거야

    이러한 과정에서 a라는 바구니는 변수라고 부르며 이 때 a의 자료형은 NUMBER이며 숫자 외에는 들어갈 수 없어야합니다.

    그러나, 자바스크립트에서는 이러한 과정을 런타임(실행) 이후 판단하기 때문에 자료형은 존재하지만 어떠한 값이든 변수에 담을 수 있습니다.

    자바스크립트는 동적타입언어이다.

    실행시 타입을 확정시키는건 편하지만 예상치 못하는 오류를 발생시킬 수 있다.

    ex)
    Java (정적 타입 언어)
        int a =5; // number
        int a = "성용" // number --> string (x)

    JavaScript (동적 타입 언어)
        let(var) a =5; // number
        let a = "성용" // string
        실행시 마음대로 바뀔 수 있다.

    TypeScript
        let a:number = 5;
        타입을 확정시킨다. 그 후에 실행

---

## 자료형(단위)의 종류

    * 원시 타입
    number (숫자, 정수 실수를 구분하지 않습니다)
    string (문자열 ex. '안녕하세요') "5" , 5
    boolean (true , false)
    null (값이 명확히 비어있다고 지정해준 상태 )
    let a = null;
    undefined (값이 지정되어있지 않은 상태)
    let a;
    symbol (이터러블 오브젝트의 키[key] 값으로 사용되는 타입)


    * 객체 타입
    object : 객체 [집단] - 이거 하나만 있다고 알고있으면 된다.
    자바스크립트를 이루고 있는 원시값을 제외한 모든 것은 객체입니다.
    자바스크립트에 배열과 map, set의 경우는 모두 눈속임에 불과

    * 저장 공간이 다르다 - 면접에서 굉장히 많이 나온다.
    원시타입은 콜스택(Call Stack)  (자바스크립트 메모리 공간)
    객체타입은 힙(Heap) (주소 값을 참조하기위 해서 주소값을 변수에 할당)
    깊은 복사와 얕은 복사의 차이!!
    ex) let seongyong = {
        age: 20,
        height: 198
        }

    에러날시 콘솔찍어서 왜 에러가 났는지 확인하고 해결해야한다.
    반드시 콘솔 찍어볼것
    오류나면 반드시 디버깅 먼저 할 것

---

## 변수

    var(x), let ,const

    1. 자바스크립트에서 변수를 선얼 할 때 자료형을 필요로 하지는 않습니다
    자바스크립트는 인터프리터 언어로 기계어로 컴파일 x
    따라서 실행 되었을 때 자료형을 추론하여 부여


    2. console.log("안녕하세요") // 안녕하세요
        console.log("안녕하세요")
        console.log("안녕하세요")
        console.log("안녕하세요")
        ex) let a = "안녕하세요"
        console.log(a) // 안녕하세요
        console.log("a") // a

        변수/상수를 선언하는 이유는 알아보기 쉽다.
        컴퓨터에게 값을 기억시키고 재사용할 수 있다

    3. 변수(상수)의 선언 방법
    let 변수명; (선언) ----> undefined -> 콜스택이라는 곳에 쌓인다.
    변수명 = 5; (할당)
    ==> let 변수명 = 5; (선언과 할당을 동시에 했다)

    4. 변수의 종류
    * 변수 (변하는 값)
    ex)
    let a = 5;
    console.log(a) // 5
    a = 6; (o) ---------- 재할당
    console.log(a) // 6

    * 상수 (항상 같은 값)
    ex)
    const a = 5;
    console.log(a)
    a = 6; (error)
    console.log(a)

    5. var의 문제점
    중복 선언이 가능
    let a = 5; -- > a = 6
    let a = 6; ----------- error (a는 이미 정의되어있어요)
    var b = 5;
    var b = 6;

## 호이스팅

    자바스크립트 실행 이전에 평가과정에서 선언부를 먼저 저장
    var의 경우는 선언부가 먼저 저장되어 실행시 선언되지 않아도 undefined라는 값을 갖고있고 이러한 현상이 마치 선언부가 상단에 올라오는 효과 같다고해서 개발자들 사이에서 이를 호이스팅이라고 부르기 시작한 것

    ex)
    console.log(a) // error, 선언도 안되었는데 왜 사용해?
    // undefined
    var a = 5;
    console.log(a); // 5

    이러한 점은 개발자들이 개발에 있어 혼동을 느낄 수 있음
    이러한 점을 어떻게 개선할 수 있을까? ES6 (ES2015)EcmaScript

    이 이후에는 let과 const를 만들어 중복선언 및 호이스팅을 개선하였다.
    (error)    (error)
    간단 요약 : let과 const는 중복선언과 선언전에 사용불가
    이 두가지 이유로 더이상 var는 사용하지 않는다.
    만약에 코드에 var이 사용되어있다면 구글링해서 옛날 코드를 긁어온 것
    그러므로 사용하면 안된다.

    최신기능이라고 쓸 수 없는 이유는 모든 브라우저에 지원되어야(실무에 사용가능해야) 사용가능하다.

## 연산자

### 산술연산자 ( +, -, \*, /, % )

    let a = 5;
    let b = 2;
    console.log(a + b) // 7

    let c = a +b ;
    console.log(c) // 7
    console.log(a - b) // 3
    console.log(a * b) // 10
    console.log(a / b) // 2.5
    console.log(a % b) // 1

    let d = true;
    javascript (true = 1, false = 0)
    console.log(a + d) // 6
    console.log(a + null) // 5
    console.log(a + undefined) // NaN (Not a Number)

### 단항 산술 연산자

    ++ 값이 1 증가
    -- 값이 1 감소

    + 영향x
    - 음수

    let a = 5;
    ++a // 6
    +a // 5

### 전위 연산자

    a++ ==> 연산 후에 값을 더해라
    ++a ==> 연산 전에 값을 더해라

    문자열 연결 연산자
    let a = "안";
    let b = "녕";
    console.log(a+b); // "안녕"

    a = '1';
    b = 2;
    console.log(a+b); // "12"
    => 피연산자 중 하나 이상이 문자열인 겨우 문자열로 동작

### 할당 연산자

    =
    ex) let a = 5;

    +=
    - 값의 누적
    - ex) let a = 5;
    a += 5; // 10 --- > a = a + 5;
    (기존값에서) a 값에 5를 더해라 (누적시켜라)

    let str = "안";
        str += "녕"; -----> str = str + "녕"
        // 안녕

### 우선 순위 연산자 ()

    ex)
    10 * 2 + 2 => 22
    10 * (2 + 2) => 40
    - if(조건식)

---

## 명제의 참/거짓을 구분할 때 사용 --> boolean 타입을 반환 (true / false)

### 논리 연산자

    || 논리합 (or) - 둘 중에 하나라도 true면 true
    && 논리곱 (and) - 둘 다 true여야만 true
    ! 부정 (not) - !true --> false1
    ex)
    (&&)
    true || true --> T --> T
    true || false --> T --> F
    false || true --> T --> F
    false || false --> F --- F

### 비교 연산자

    == 동등 비교 ----------> 값만 같은지
    === 일치 비교 ---------> 값과 자료형이 같은지
    ex) 5 , "5" 5 === "5" // false
        5 == "5" // true

    != 부등 비교 ----------> 값만 다른지
    ex) "5" != 3 // true
        "5" != 5 // false

    !== 불일치 비교 -------> 값과 타입이 다른지
    ex)      "5" !== 5 // true

---

## 제어문

    1. 조건문
    특정한 조건이 주어지고 그 조건의 평가(참,거짓 [논리연산자, 비교연산자])에 따라 결과가 달라지는 명령문

    (1) if .. else
    if --> 만약에 범위가 지정되어 있고, 조건이 1개이면 보통 if문을 사용
    ex)
    let a = 4
    if(a === 5) {
    // 조건식이 참이면 실행할 문장
    ++a
    아니면
    } else {
    // 조건식이 거짓이면 실행할 문장
    --a
    }

    ----------------------------------

    if(조건식1){
    ...1
    조건식이 1이 참이면 실행
    } else if(조건식2){
    ...
    조건식이 2가 참이면 실행
    } else {
    ...
    그 외의 경우 실행
    (조건식1과 조건식2 거짓일 경우)
    }

    2) switch
    변수의 값을 기준으로 일치하는 문장 실행
    여러가지 경우의 수가 많을 경우

    switch(기준으로 삼을 변수){
        case 값1:
            변수가 값1과 일치하면 실행할 문장;
        case 값2:
            변수가 값2와 일치하면 실행함 문장;
        default:
            기본값;
        }

---

## 제어문

### 조건문

    if ["만약에, 아니면", "조건식"]
    switch ["값", "case", "break"]

### 반복문

    주어진 "조건식"의 결과가 참(true)일 때까지 해당 블럭(구역, { ... } )의 로직(기능,코드)를 반복 실행한다.

    (1) for문 -- 가족 (forEach, for..in, for..of)
    ex)
    for(초기화식; 조건식; 증감식){
    조건식이 참인 경우 실힝할 문장
    }

    for(let i = 0; i < 10; i++){
    console.log(i) -- 반복 실행할 문장
    }

    console    i
    // 0 ----> 1
    // 1 ----> 2
    ....
    // 9 ----> 10 -- 여기까지만 반복


    (2) while문 - 무한 루프에 많이 사용된다
    while(조건식){
        조건식이 true일 동안 실행할 문장
    }

### 무한루프

    외부의 값에 의해 탈출문이 실행될 때까지 무한 반복

    let count = 0;
    while(true){
        .. 무한 반복
        count++;
        if(count === 3) break;
        }

### do... while문

    while문과 기능은 같지만 조건식이 false라 할지라도 "무조건 한 번"은 실행하고 반복

    let count = 3;
    do{
        console.lolg(count)
    } while( count < 3 )
    // 3

---

## 함수 ( Function )

    자바스크립트는 함수 지향형 프로그래밍
    최근 들어서는 객체 지향의 장점들이 녹아드는 중

    함수 지향이란 무엇일까?
    프로그래밍 패러다임의 한 종류
    순수 함수를 조합하고 함수를 일급 객체로서 사용하여 프로그래밍 하는 방식

    프로그래밍 패러다임이란?
    개발자에게 프로그래머로서의 관점을 갖게하고 결정하는 역할 => 개발 방법

    명령형
    절차 지향 : 순서를 중요 시, 컴퓨터의 처리구조와 비슷, 속도가 빠름 (C, Cobol...)
    객체 지향 : 객체(집단)의 상호 작용을 중요 시, 유지 보수 용이 (Java, C++)
    선언형 (어떻게 할 것인가보다는 무엇을 할 것인가가 중요)
    함수 지향 : 순수 함수를 조합하고 프로그래밍 하는 방식 (Javscript)

    함수 지향 프로그래밍 관련 용어

    불변성 = 함수 밖에서 데이터의 변형을 일으켜서는 안된다
    클로저 = 부모 함수가 실행 종료되어도 참조할 수 있는 내부 함수는 기억된다
    순수함수 = 입력 값에만 의존하고, 부수효과는 연산에 영향을 미치지 않는다
    일급객체 함수 = 함수를 입력 값(파라미터, 매개변수, 인자)으로 사용할 수 있고 반환 값(출력)으로 사용할 수 있다
    유지관리가능성 = 외부 효과에 의존되지 않으면 해당 부분만 수정하면 되기 때문에 유지보수가 쉽다
    모듈화 = 함수를 분리하여 재사용 및 관리가 용이하도록 구성해야한다
    부수효과 = 함수 밖에서 함수의 연산에 영향을 끼치면 안된다. (외부효과, 사이드이펙트)
    참조투명성 = 동일한 값에는 항상 동일한 반환 값

    p.s 위 언어를 모두 완벽하게 이해하고 코드를 작성해야한다면 처음부터는 어렵다.
    따라서 당장은 자바스크립는 함수를 기반으로 하는 함수 지향형 프로그래밍이다.

---

## 함수

    어떠한 기능을 만든다에 의존하고 초점
    ex)
    나는 두개의 숫자를 전달받고 두 숫자를 합치는 함수를 작성하고 싶다

### 선언부

    - 선언부는 함수를 실행하는 것이 아니라
    - 기능만 구성하여 컴퓨터에게 기억시키는 것 => 재사용
    function addNumber(파라미터1, 파라미터2, ....)
    ------------------------\
    실행부에서 전달받은 값
    파람, 매개변수, 인자

    {
        ... 작성하고 싶은 연산
        파라미터1 + 파라미터2
        반환 값 (생략가능)
    }

    실행부
    함수명(전달 값1, 전달 값2);

    ex)
    function sum(num1, num2){
        console.log(num1 + num2)
    }

    sum(3,5)

            반환값

                sum(3,5)
                +9;

                console.log(sum(3,5) + 9)
                            ------ undefined



                function minus(num1, num2){
                  console.log(num1 - num2)
                  return num1 - num2
                }

                console.log(minus(3,5) + 9

                    -> 기능 -> 값이 할당


                * 반환 값은 해당 함수 실행부에 값을 부여한다는 의미
                  만약에 return이 없다면 비즈니스 로직만 실행하고 값은 undefined

                  즉 함수의 기능은 정삭작동하나 값은 존재하지 않는 상태
                  따라서, 이 함수에 값을 주자 return이 있음

---

    (1) 기명함수, 익명함수

        기명함수: 이름을 지어준다
        익명함수: 이름이 없는 함수

        function hello(){
            console.log("hello")
        }

        --------------------------------------------------------------------------

        function(){
            console.log("world")
        }
        -- 다른 함수의 매개변수로 전달되어 실행되는 함수 (콜백함수 클로저, 즉시실행함수)
        -- 재사용 가능성이 없는 경우

        --------------------------------------------------------------------------

        ex) array.map(function(el,index,arr){})


    (2) 재귀함수, 즉시실행함수

            재귀 함수
                함수 안에서 같은 함수를 실행 (반복)
                [코딩테스트 최단 경로 관련 알고리즘 문제 단골]
                함수 안에서 챗바퀴 돌듯이 재실행된다.

                function f(n){
                    if(n <= 1){
                        return 1
                    }
                    return n + f(n-1)
                }

                f(10) // 55
                10 + 9 + 8 ... + 1 = 55

                반복문에도 사용되긴 하지만 보통 탐색에 제일 많이 사용된다.

                나중에 무조건 보게 되는 로직


            즉시실행함수
                실행부 없이 선언부만으로 바로 실행
                보통은 익명함수로 주는 경우가 많음

                괄호 두개 열어준다

                (functio(){
                    ... 로직
                })()

    (3) * 화살표 함수
            function 키워드 대신 (=>)를 사용하여 보다 간략한 방법으로 함수 선언 가능
            ES6, ES7의 문법
            react 사용하면서 거의 이것만 사용했다...

            ex)

                function a (param1, param2){

                }


                function(){

                }

                일반자바스크립트에서 주로 사용
                -----------------------------

                const a = (pram1, param2) => {

                }

                () =>  {

                }

                리액트에서 주로 사용
                -----------------------------
                기능적으로 function과 화살표함수가 차이가 없다.
                실무에서는 화살표함수 거의 사용한다.
                둘중에 하나로 통일해서 사용해야한다.

---
