
  hook 함수

    react에서 화면이 랜더링되는 조건?
        react의 컴포넌트에는 상태(state)라는 값이 존재, 해당 state가 변경되어야만 UI를 업데이트 합니다.

    과거에는 class component를 사용했고 life cycle(생명 주기)이라고 하는 이벤트 관리가 존재했습니다.
    페이지가 처음 열렸을 때 ~ 닫혔을 때까지의 상태 변화나 이벤트(함수) 트리거 등을 담당

    그러나 react 16버전(2018, 2019) 이후로 class 컴포넌트는 더이상 리엑트에서 개발 지원을하지 않으며
    함수형 컴포넌트가 생김으로서 life cycle 대신에 상태를 관리하고, 이벤트를 트리거 해주는 hooks 함수가 등장

    (1) useState
        - react의 상태를 생성하고 변경할 수 있는 훅 함수
        - useState로 생성된 상태의 값이 변경될 떄마다 리랜더링 한다

    (2) useRef
        - 상태는 아니지만, 리랜더 되어도 값이 유지
        - html 요소에 접근하기 위해 사용, 그러나 react에서 dom api에 접근하는 행위는 지양

    ------------------------------------------------------------------------------------

    (3) useMemo
        - * 함수가 실행되어 반환(return)하는 값 * 을 캐싱하고
          랜더링 되어도 연산을 다시하지 않고 (랜더링 함수가 재실행되면 함수 연산도 재실행되어야하지만 다시 하지 않음)
          값을 캐싱(저장)하여 재사용

    (4) useCallback
        - 랜더링 함수가 리랜더링 되면 함수나 변수등도 다시 선언하게 되는데, useCallback을 사용하여 선언한 함수는
          랜더링 되어도 ** 다시 선언하지 않고 * 저장되어있던 값을 재사용   / 선언과 결과값이 중요!!!

    ex)
        상태가 변했어요! -> 리랜더링 -> 랜더함수 재실행 -> 복잡한 함수 실행시간 지연 -> 랜더링 지연

        1. 반드시 연산해야하는 경우 -> 랜더링 될 때마다 값이 달라지는 경우
        2. 값이 랜더링 되어도 똑같은 함수라면 연산을 다시 할 필요가 있을까요?

        메모이제이션(메모라이제이션) - 캐싱되어있는 연산 값을 사용

        메모이제이션은 반드시 하는게 좋을까요?
            저장한다는 것은 코스트(비용)가 있을까요 없을까요? 이미 저장하는 것만으로도 코스트는 들어갑니다.
            따라서, 적절한 경우에 맞춰 메모이제이션을 활용하는 것이
            좋은데, 그렇다면 useMemo와 useCallback이 저장되는 코스트보다 효율적인 시점을 알 수 있을까요?
            렌더링 시간을 하나하나 체크하면서 비교하면 비교를 할 수는 있지만 실무에서는 그럴 수는 없다.

            각 함수마다 실행 시간이 다르기 때문에 이를 예측하는 것은 매우 어려운 일
            따라서 컨벤션이나 자기만의 규칙을 만들어 메모이제이션을 하는 것이 가장 생산성 있는 작업

            * useCallback과 useMemo는 어느 시점에 사용해야할까요? - 회사 면접 질문
            예시) 강사님 - 시간복잡도가 On2(반복문), axios 요청이 2회 이상 일어날 때
            기준은 내가 만들어야 한다. 제일 좋은 방법 - 시간 측정해서 퍼포먼스를 측정하는 것

    ------------------------------------------------------------------------------------

    (5) useEffect

        페이지의 생명주기 동안 일으키고 싶은 외부 효과등을 제어할 수 있는 훅 함수
        => 페이지가 열려있는 동안, 여러분들이 특정 함수를 원하는 시기에 호출할 수 있음

        마운트(페이지가 처음 열렸을 때), 언마운트(페이지가 닫혔을 때), 의존성 배열의 값이 바뀌었을 때

    ------------------------------------------------------------------------------------